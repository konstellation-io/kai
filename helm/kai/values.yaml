# -- Provide a name in place of kai for `app.kubernetes.io/name` labels
nameOverride: ""
# -- Whether to setup developement mode
developmentMode: false
rbac:
  # -- Whether to create the roles for the services that could use custom Service Accounts
  create: true
config:
  # -- Base domain name for Admin API and K8S Manager apps
  baseDomainName: "kai.local"
  tls:
    # -- Whether to enable TLS
    enabled: false
    # -- An existing secret containing a valid wildcard certificate for the value provissioned in `.config.baseDomainName`. Required if `config.tls.enabled = true`
    certSecretName: ""
  admin:
    # -- Whether to enable CORS on Admin API
    corsEnabled: true
  mongodb:
    connectionString:
      # -- The name of the secret that contains a key with the MongoDB connection string.
      secretName: ""
      # --The name of the secret key that contains the MongoDB connection string.
      secretKey: ""
  minio:
    # -- Default region (only affect to Minio buckets)
    # @default -- us-east-1
    defaultRegion: ""
    # Transition Objects from MinIO to remote storage
    # @default: Only one type of tier can be set, otherwise the deployment will use the first set tier (1.aws 2.gcp 3.azure) ignoring the rest
    tier:
      # -- Whether to enable MinIO Tiering
      # @default: If is disable MinIO will use only local storage
      enabled: false
      # -- Tier name
      # @default -- KAI-REMOTE-STORAGE
      name: ""
      # -- Remote storage bucket name (must exist)
      remoteBucketName: ""
      # -- Prefix or path in bucket where object transition will happen (will be created if not exist)
      # @default -- DATA
      remotePrefix: ""
      # -- Transition Objects from MinIO to AWS S3
      aws:
        # -- The Region where the remote bucket was created.
        # @default -- us-east-1
        region: ""
        # -- S3 Service endpoint URL
        # @default -- https://s3.amazonaws.com
        endpointURL: ""
        # -- AWS authentication config
        # @default: first look for the keys in pre-existing kubernetes secret object (secretName and secretKeyNames), if not set, look for the keys in values.yaml (accessKeyID and secretAccessKey)
        auth:
          # -- Name of the secret that contains the credentials for S3
          secretName: ""
          # -- Secret reference for AWS access keys
          secretKeyNames:
            # -- Name of the key in the secret that contains the access key ID
            accessKey: ""
            # -- Name of the key in the secret that contains the secret access key
            secretKey: ""
          # -- S3 Access Key ID if no secret is used
          accessKeyID: ""
          # -- S3 Secret Access Key if no secret is used
          secretAccessKey: ""
adminApi:
  # -- Default application log level
  logLevel: INFO
  image:
    # -- Image repository
    repository: konstellation/kai-admin-api
    # -- Image tag
    tag: 0.2.0-develop.37
    # -- Image pull policy
    pullPolicy: IfNotPresent
  # -- Hostname. This will be used to create the ingress rule and must be a subdomain of `.config.baseDomainName`
  host: api.kai.local
  ingress:
    ## This Chart has been developed using Kong Ingress Controller by default.
    ## Using the following default annotations ensures its correct operation.
    ## Ref: https://kubernetes.github.io/ingress-Kong/
    ##
    # -- The name of the ingress class to use
    className: kong
    # -- Ingress annotations
    # @default -- See `adminApi.ingress.annotations` in [values.yaml](./values.yaml)
    annotations: {}
  storage:
    # -- Storage class name
    class: standard
    # -- Storage class size
    size: 1Gi
    # -- Persistent volume mount point. This will define Admin API app workdir too.
    path: /admin-api-files
  # -- Define which Nodes the Pods are scheduled on.
  ## ref: https://kubernetes.io/docs/user-guide/node-selection/
  ##
  nodeSelector: {}
  # -- Assign custom affinity rules to the Admin API pods
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  ##
  affinity: {}
  # nodeAffinity:
  #   requiredDuringSchedulingIgnoredDuringExecution:
  #     nodeSelectorTerms:
  #     - matchExpressions:
  #       - key: kubernetes.io/e2e-az-name
  #         operator: In
  #         values:
  #         - e2e-az1
  #         - e2e-az2

  # -- Tolerations for use with node taints
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
  # - key: "key"
  #   operator: "Equal"
  #   value: "value"
  #   effect: "NoSchedule"
k8sManager:
  image:
    # -- Image repository
    repository: konstellation/kai-k8s-manager
    # -- Image tag
    tag: 0.2.0-develop.37
    # -- Image pull policy
    pullPolicy: IfNotPresent
  serviceAccount:
    # -- Whether to create the Service Account
    create: true
    # -- The name of the service account.
    # @default: A pre-generated name based on the chart relase fullname sufixed by `-k8s-manager`
    name: ""
    # -- The Service Account annotations
    annotations: {}
  triggers:
    ingress:
      # -- The ingressClassName to use for the enypoints' generated ingresses
      className: "kong"
      # -- The annotations that all the generated ingresses for the entrypoints will have
      # @default -- See `entrypoints.ingress.annotations` in [values.yaml](./values.yaml)
      annotations:
      # konghq.com/protocol: grpc,grpcs
  # -- Define which Nodes the Pods are scheduled on.
  ## ref: https://kubernetes.io/docs/user-guide/node-selection/
  ##
  nodeSelector: {}
  # -- Assign custom affinity rules to the K8S Manager pods
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  ##
  affinity: {}
  # nodeAffinity:
  #   requiredDuringSchedulingIgnoredDuringExecution:
  #     nodeSelectorTerms:
  #     - matchExpressions:
  #       - key: kubernetes.io/e2e-az-name
  #         operator: In
  #         values:
  #         - e2e-az1
  #         - e2e-az2

  # -- Tolerations for use with node taints
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
  # - key: "key"
  #   operator: "Equal"
  #   value: "value"
  #   effect: "NoSchedule"
keycloak:
  # -- Hostname. This will be used to create the ingress rulem and to configure Keycloak and must be a subdomain of `.config.baseDomainName`
  host: "auth.kai.local"
  auth:
    # -- Keycloak admin username
    adminUser: admin
    # -- Keycloak admin password
    adminPassword: "123456"
    existingSecret:
      # -- The name of the secret that contains a key with the Keycloak admin password. Existing secret takes precedence over `adminUser` and `adminPassword`
      name: ""
      # -- The name of the secret key that contains the Keycloak admin username.
      userKey: ""
      # -- The name of the secret key that contains the Keycloak admin password.
      passwordKey: ""
  # -- Args to pass to the Keycloak startup command. This takes precedence over options passed through env variables
  argsOverride: {}
  # argsOverride:
  #  - "--hostname-strict-https"

  # -- Keycloak extra env vars in the form of a list of key-value pairs
  extraEnv: {}
  # extraEnv:
  #  KC_HOSTNAME_STRICT_HTTPS: "false"
  #  KC_FEATURES: "admin-fine-grained-authz"

  # -- The name of the realm that will be crated on Keycloak first startup
  realmName: "konstellation"
  kong:
    # -- The name of the OIDC Kong plugin that should be installed on Kong ingress controller
    oidcPluginName: "oidc"
    oidcClient:
      # -- The name of the OIDC client in Keycloak for Kong
      clientId: "kong-oidc"
      # -- The secret for the OIDC client that will be created on Keycloak first startup
      secret: ""
  kli:
    oidcClient:
      # -- The name of the OIDC client in Keycloak for KLI
      clientId: "kai-kli-oidc"
  adminApi:
    oidcClient:
      # -- The name of the OIDC client in Keycloak for the master realm admin
      clientId: "admin-cli"
  minio:
    # -- The name of the OIDC client in Keycloak for MinIO
    oidcClient:
      # -- The name of the OIDC client in Keycloak for Kong
      clientId: "minio"
      # -- The secret for the OIDC client that will be created on Keycloak first startup
      secret: ""
  config:
    # -- Whether to enable metrics
    metricsEnabled: "false"
    # -- Whether to enable http
    httpEnabled: "true"
    # -- Disables dynamically resolving the hostname from request headers. Should always be set to true in production, unless proxy verifies the Host header.
    hostnameStrict: "false"
    # -- The proxy address forwarding mode if the server is behind a reverse proxy. Valid values are `none`, `edge`, `reencrypt` and `passthrough`
    proxy: edge
    # -- If the server should expose health check endpoints. If set to "false", container liveness and readiness probes should be disabled.
    healthEnabled: "true"
  db:
    # -- Keycloak database type
    type: postgres
    auth:
      # -- The database name
      database: ""
      # -- The database hostname
      host: ""
      # -- The database port
      port: ""
      # -- The name of the secret that contains the database connection config keys.
      secretName: ""
      # -- The name of the secret key that contains the database host.
      secretHostKey: ""
      # -- The name of the secret key that contains the database port. Takes precedence over `host`
      secretPortKey: ""
      # -- The name of the secret key that contains the database username. Takes precedence over `port`
      secretUserKey: ""
      # -- The name of the secret key that contains the database password.
      secretPasswordKey: ""
      # -- The name of the secret key that contains the database name. Takes precedence over `database`
      secretDatabaseKey: ""
  image:
    # -- The image repository
    repository: quay.io/keycloak/keycloak
    # -- The image pull policy
    pullPolicy: IfNotPresent
    # -- The image tag
    tag: "21.1.1"
  # -- Image pull secrets
  imagePullSecrets: []
  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""
  # -- Pod annotations
  podAnnotations: {}
  # -- Pod security context
  podSecurityContext: {}
  # fsGroup: 2000

  # Container security Context
  securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

  service:
    # -- Service type
    type: ClusterIP
    ports:
      # -- The http port the service will listen on. Only
      http: 8080
      # -- The https port the service will listen on
      https: 8443
  ingress:
    ## This Chart has been developed using Kong Ingress Controller by default.
    ## Using the following default annotations ensures its correct operation.
    ## Ref: https://kubernetes.github.io/ingress-Kong/
    ##

    # -- The name of the ingress class to use
    className: kong
    # -- Ingress annotations
    # @default -- See `keycloak.ingress.annotations` in [values.yaml](./values.yaml)
    annotations: {}
  # -- Container resources
  resources: {}
  # -- Container liveness probe
  livinessProbe:
    httpGet:
      path: /health/live
      port: http
    initialDelaySeconds: 30
    timeoutSeconds: 5
    periodSeconds: 10
    failureThreshold: 3
  # -- Container readiness probe
  readinessProbe:
    httpGet:
      path: /health/ready
      port: http
    initialDelaySeconds: 30
    timeoutSeconds: 5
    periodSeconds: 10
    failureThreshold: 3
  # -- Define which Nodes the Pods are scheduled on.
  nodeSelector: {}
  # -- Assign custom tolerations to the Keycloak pods
  tolerations: []
  # -- Assign custom affinity rules to the Keycloak pods
  affinity: {}
  # -- Extra volumes
  extraVolumes: []
  # -- Extra volume mounts
  extraVolumeMounts: []
nats:
  image:
    # -- Image repository
    repository: nats
    # -- Image tag
    tag: 2.8.4
    # -- Image pull policy
    pullPolicy: IfNotPresent
  client:
    # -- Port for client connections
    port: 4222
  jetstream:
    storage:
      # -- Whether to enable a PersistentVolumeClaim for Jetstream
      enabled: true
      # -- Storage class name for the Jetstream PersistentVolumeClaim
      storageClassName: standard
      # -- Storage size for the Jetstream PersistentVolumeClaim. Notice this is also used for the Jetstream storage limit configuration even if PVC creation is disabled
      size: 5Gi
      # -- Directory to use for JetStream storage when using a PersistentVolumeClaim
      storageDirectory: /data
    memStorage:
      # -- Whether to enable memory storage for Jetstream
      enabled: true
      # -- Memory storage max size for JetStream
      size: 2Gi
  logging:
    # -- Whether to enable logging debug mode
    debug: false
    # -- Whether to enable logging trace mode
    trace: false
    # -- Timestamp log entries
    logtime: true
  limits:
    # -- Maximum number of active client connections.
    # @default -- 64K
    maxConnections:
    # -- Maximum numbers of subscriptions per client and leafnode accounts connection.
    # @default -- 0 (unlimited)
    maxSubscriptions:
    # -- Maximum length of a protocol line (including combined length of subject and queue group). Increasing this value may require cliet changes. Applies to all traffic
    # @default -- 4KB
    maxControlLine:
    # -- Maximum number of bytes in a message payload. Reducing this size may force you to implement chunking in your clients. Applies to client and leafnode payloads. It is not recommended to use values over 8MB but `max_payload` can be set up to 64MB. The max payload must be equal or smaller to the `max_pending` value.
    # @default -- 1MB
    maxPayload:
    # -- Maximum number of seconds the server will block when writing. Once this threshold is exceeded the connection will be closed.
    # @default -- 10s
    writeDeadline:
    # -- Maximum number of bytes buffered for a connection Applies to client connections. Note that applications can also set 'PendingLimits' (number of messages and total size) for their subscriptions.
    # @default -- 64MB
    maxPending:
    # -- After how many unanswered pings the server will allow before closing the connection.
    # @default -- 2
    maxPings:
    # How many seconds should pass before sending a PING
    # to a client that has no activity.
    pingInterval:
    # -- Grace period after pod begins shutdown before starting to close client connections
    lameDuckGracePeriod: "10s"
    # -- Duration over which to slowly close close client connections after lameDuckGracePeriod has passed
    lameDuckDuration: "30s"
  # -- Define which Nodes the Pods are scheduled on.
  ## ref: https://kubernetes.io/docs/user-guide/node-selection/
  ##
  nodeSelector: {}
  # -- Assign custom affinity rules to the NATS pods
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  ##
  affinity: {}
  # nodeAffinity:
  #   requiredDuringSchedulingIgnoredDuringExecution:
  #     nodeSelectorTerms:
  #     - matchExpressions:
  #       - key: kubernetes.io/e2e-az-name
  #         operator: In
  #         values:
  #         - e2e-az1
  #         - e2e-az2
  # -- Tolerations for use with node taints
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
  # - key: "key"
  #   operator: "Equal"
  #   value: "value"
  #   effect: "NoSchedule"
natsManager:
  image:
    # -- Image repository
    repository: konstellation/kai-nats-manager
    # -- Image tag
    tag: 0.2.0-develop.37
    # -- Image pull policy
    pullPolicy: IfNotPresent
registry:
  image:
    # -- Image repository
    repository: registry
    # -- Image tag
    tag: 2.8.2
    # -- Image pull policy
    pullPolicy: IfNotPresent
  # -- Image pull secrets
  imagePullSecrets: []
  serviceAccount:
    # -- Specifies whether a service account should be created
    create: true
    # -- Annotations to add to the service account
    annotations: {}
    # -- The name of the service account to use. If not set and create is true, a name is generated using the fullname template
    name: ""
  # -- Pod annotations
  podAnnotations: {}
  # -- Pod security context
  podSecurityContext: {}
  # fsGroup: 2000

  # Container security Context
  securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

  service:
    # -- Service type
    type: ClusterIP
    ports:
      # -- The http port the service will listen on. Only
      http: 5000
  # -- A string contaning the config for Docker Registry. Ref: https://docs.docker.com/registry/configuration/.
  config: ""
  configSecret:
    # -- Takes precedence over 'registry.config'. The name of the secret that contains the registry config file.
    name: ""
    # -- The name of the secret key that contains the registry config file
    key: ""
  auth:
    # -- Registry username
    # @default -- user
    user: ""
    # -- Registry password
    # @default -- password
    password: ""
  storage:
    # -- Whether to enable persistence
    enabled: true
    # -- Storage class name
    storageClass: ""
    # -- Access mode for the volume
    accessMode: ReadWriteOnce
    # -- Storage size
    size: 10Gi
    # -- Persistent volume mount point. This will define Registry app workdir too.
    path: /var/lib/registry
  # -- Container resources
  resources: {}
  # -- The container port
  containerPort: 5000
  # -- Hostname. This will be used to create the ingress rule and must be a subdomain of `.config.baseDomainName`
  host: registry.kai.local
  ingress:
    # -- The name of the ingress class to use
    className: kong
    # -- Ingress annotations
    # @default -- See `adminApi.ingress.annotations` in [values.yaml](./values.yaml)
    annotations: {}
  # -- Define which Nodes the Pods are scheduled on.
  ## ref: https://kubernetes.io/docs/user-guide/node-selection/
  ##
  nodeSelector: {}
  # -- Assign custom affinity rules to the pods
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  ##
  affinity: {}
  # nodeAffinity:
  #   requiredDuringSchedulingIgnoredDuringExecution:
  #     nodeSelectorTerms:
  #     - matchExpressions:
  #       - key: kubernetes.io/e2e-az-name
  #         operator: In
  #         values:
  #         - e2e-az1
  #         - e2e-az2
  # -- Tolerations for use with node taints
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
  # - key: "key"
  #   operator: "Equal"
  #   value: "value"
  #   effect: "NoSchedule"
  # -- Extra volumes for the registry deployment
  extraVolumes: []
  # -- Extra volume mounts for the registry deployment
  extraVolumeMounts: []
## The following values are only a small set of options. For a full list see
## the official MinIO chart at https://github.com/minio/minio/tree/master/helm/minio
##
minio:
  image:
    # -- Image repository
    repository: quay.io/minio/minio
    # -- Image tag
    tag: RELEASE.2023-09-30T07-02-29Z
    # -- Image pull policy
    pullPolicy: IfNotPresent
  mcImage:
    # -- Image repository
    repository: quay.io/minio/mc
    # -- Image tag
    tag: RELEASE.2023-09-29T16-41-22Z
    # -- Image pull policy
    pullPolicy: IfNotPresent
  # -- Sets minio mode
  mode: standalone
  # -- Internal port number for MinIO S3 API container
  minioAPIPort: "9000"
  # -- Internal port number for MinIO Browser Console container
  minioConsolePort: "9001"
  # -- Sets Root user
  # @default -- Randomly generated value
  rootUser: ""
  # -- Sets Root password
  # @default -- Randomly generated value
  rootPassword: ""
  # -- Use an exising secret for root user and password
  existingSecret: ""
  # -- Sets pods resources
  resources:
    requests:
      memory: 256Mi
  persistence:
    # -- Enables persistent storage using PVC
    enabled: true
    # -- Storage class name
    storageClass: ""
    # -- Access mode for the volume
    accessMode: ReadWriteOnce
    # -- Storage size
    # @note: If Tier is enabled, ensure enough space to MinIO have time to transfer objects to external storage and free space in local persistence storage
    size: 10Gi
  service:
    # -- Service type
    type: ClusterIP
    # -- Internal port number for MinIO S3 API service
    port: "9000"
  ingress:
    # -- Enable ingress for MinIO API
    enabled: true
    # -- The name of the ingress class to use
    ingressClassName: kong
    # -- Ingress labels
    labels: {}
    # -- Ingress annotations
    annotations: {}
    # -- Ingress hostnames
    hosts:
      - storage.kai.local
    # -- Ingress TLS configuration
    tls: []
  consoleIngress:
    # -- Enable ingress for MinIO Web Console
    enabled: true
    # -- The name of the ingress class to use
    ingressClassName: kong
    # -- Ingress labels
    labels: {}
    # -- Ingress annotations
    annotations: {}
    # -- Ingress hostnames
    hosts:
      - storage-console.kai.local
    # -- Ingress TLS configuration
    tls: []
